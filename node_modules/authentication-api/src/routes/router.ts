import AuthenticationMiddleware from '@/middlewares/AuthenticationMiddleware'
// import CSRFMiddleware from '@/middlewares/CSRFMiddleware'
import UserModel from '@/models/UserModel'
import userRouter from '@/routes/UserRoute'
import BCryptService from '@/services/BCryptService'
import JWTService from '@/services/JWTService'
import { Router } from 'express'

import type Express from 'express'

const router = Router()


router.use('/users', AuthenticationMiddleware, userRouter)

router.get('/', async (req, res) => {

    const hash = await BCryptService.hash('Cheetara@2023')
    res.json({ hash })
})

router.post('/login', async (req: Express.Request, res: Express.Response) => {

    const { username, password } = req.body;

    const user = username == UserModel.username && UserModel

    if (user && (await BCryptService.compare(password, user.password))) {
        const accessToken = JWTService.generateAccessToken({ username: user.username, roles: user.roles });
        const refreshToken = JWTService.generateRefreshToken({ username: user.username });

        res.cookie('refreshToken', refreshToken, {
            httpOnly: true,
            path: '/',
            secure: true,
            sameSite: 'lax'
        });

        res.json({ accessToken });
    } else
        res.status(401).json({ message: 'Credenciais inválidas' });

})

router.get('/logout', AuthenticationMiddleware, (req, res) => {
    res.clearCookie('accessToken');
    res.clearCookie('refreshToken');

    res.end();
})

// router.get('/csrf-token',, (req: Express.Request, res: Express.Response, next: Express.NextFunction) => {
//     const newToken = req.csrfToken();

//     res.cookie('XSRF-TOKEN', newToken, {
//         httpOnly: true,
//         sameSite: 'strict',
//         secure: process.env.NODE_ENV === 'production',
//     });

//     res.json({ csrfToken: newToken });
// });

router.post('/refresh-token', (req: Express.Request & { sessions?: any }, res: Express.Response) => {
    const refreshToken = req.cookies.refreshToken;

    if (refreshToken) {
        JWTService.verifyRefreshToken(refreshToken, (err, decoded) => {
            if (err) {
                res.status(403).json({ message: 'Token inválido' });
                return
            }

            const username = (decoded as Record<string, any>).username;

            const newAccessToken = JWTService.generateAccessToken({ username });
            res.json({ accessToken: newAccessToken });
        })
    } else res.status(403).json({ message: 'Token inválido' });
})

export default router